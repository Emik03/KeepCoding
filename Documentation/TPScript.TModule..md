#### [KeepCoding](index.md 'index')
### [KeepCoding](KeepCoding.md 'KeepCoding')
## TPScript&lt;TModule&gt; Class
Base class for TwitchPlays support for solvable and needy modded modules in Keep Talking and Nobody Explodes.   
```csharp
public abstract class TPScript<TModule> : KeepCoding.CacheableBehaviour,
KeepCoding.ITP
    where TModule : KeepCoding.ModuleScript
```
#### Type parameters
<a name='KeepCoding.TPScript.TModule..TModule'></a>
`TModule`  
  

Inheritance [UnityEngine.MonoBehaviour](https://docs.microsoft.com/en-us/dotnet/api/UnityEngine.MonoBehaviour 'UnityEngine.MonoBehaviour') &#129106; [CacheableBehaviour](CacheableBehaviour.md 'KeepCoding.CacheableBehaviour') &#129106; TPScript&lt;TModule&gt;  

Implements [ITP](ITP.md 'KeepCoding.ITP')  

| Fields | |
| :--- | :--- |
| [AutoSolve](TPScript.TModule..AutoSolve.md 'KeepCoding.TPScript&lt;TModule&gt;.AutoSolve') | Yield return this to indicate automatically solving the module, as if it threw an exception while solving.<br/> |
| [CancelDetonate](TPScript.TModule..CancelDetonate.md 'KeepCoding.TPScript&lt;TModule&gt;.CancelDetonate') | Yield return this to indicate cancelling a previously issued delayed detonation command on the same module.<br/> |
| [Cancelled](TPScript.TModule..Cancelled.md 'KeepCoding.TPScript&lt;TModule&gt;.Cancelled') | Yield return this to indicate that you have stopped processing the command in response to the [KeepCoding.TPScript&lt;&gt;.TwitchShouldCancelCommand](https://docs.microsoft.com/en-us/dotnet/api/KeepCoding.TPScript-1.TwitchShouldCancelCommand 'KeepCoding.TPScript`1.TwitchShouldCancelCommand') bool being set to true.<br/> |
| [EndMultipleStrikes](TPScript.TModule..EndMultipleStrikes.md 'KeepCoding.TPScript&lt;TModule&gt;.EndMultipleStrikes') | Yield return this to indicate that the strike tracker should be enabled. If any strikes were issued during the time it was disabled, they will be awarded and the routine stopped at that point, otherwise, it will just cancel the "VoteNay Module {id} got 0 strikes! +0 strike to {Nickname}" message that would otherwise be posted. Likewise, if the module was solved at the time this command is issued, the processing will be stopped as of that point as well.<br/> |
| [EndWaitingMusic](TPScript.TModule..EndWaitingMusic.md 'KeepCoding.TPScript&lt;TModule&gt;.EndWaitingMusic') | Yield return this to indicate stopping the waiting music mid-command.<br/> |
| [HideCamera](TPScript.TModule..HideCamera.md 'KeepCoding.TPScript&lt;TModule&gt;.HideCamera') | Yield return this to hide the heads-up display and cameras while doing quaternion rotations, if it is expected that the camera/hud will get in the way.<br/> |
| [MultipleStrikes](TPScript.TModule..MultipleStrikes.md 'KeepCoding.TPScript&lt;TModule&gt;.MultipleStrikes') | Yield return this to indicate that the issued command is going to cause more than one strike, so should disable the internal strike tracker in order to avoid flooding the chat with "VoteNay Module {id} got a strike! +1 strike to {Nickname}" for as many strikes as will be awarded. This also disables the internal solve tracker as well. This allows for sending additional messages or continue processing commands regardless of the solve/strike state.<br/> |
| [Solve](TPScript.TModule..Solve.md 'KeepCoding.TPScript&lt;TModule&gt;.Solve') | Yield return this to indicate that this command will solve the module at some later point; all this does is tell Twitch Plays to attribute the solve to the author of this command.<br/> |
| [Strike](TPScript.TModule..Strike.md 'KeepCoding.TPScript&lt;TModule&gt;.Strike') | Yield return this to indicate that this command will cause a strike at some later point; all this does is tell Twitch Plays to attribute the strike to the author of this command.<br/> |
| [ToggleWaitingMusic](TPScript.TModule..ToggleWaitingMusic.md 'KeepCoding.TPScript&lt;TModule&gt;.ToggleWaitingMusic') | Yield return this to toggle the waiting music on and off mid-command.<br/> |
| [TryCancelSequence](TPScript.TModule..TryCancelSequence.md 'KeepCoding.TPScript&lt;TModule&gt;.TryCancelSequence') | Yield return this to indicate that the `KMSelectable[]` sequence that follows this command should be cancelled if a "!cancel" or "!stop" is issued mid-way through that sequence.<br/> |
| [UnsubmittablePenalty](TPScript.TModule..UnsubmittablePenalty.md 'KeepCoding.TPScript&lt;TModule&gt;.UnsubmittablePenalty') | Yield return this to indicate that the command couldn't submit an answer and should only be used to prevent users from guessing the answer. This should not be used if an answer could never be submittable for a module.<br/> |
| [WaitingMusic](TPScript.TModule..WaitingMusic.md 'KeepCoding.TPScript&lt;TModule&gt;.WaitingMusic') | Yield return this to indicate playing the waiting music if a command will take long to finish.<br/> |

| Properties | |
| :--- | :--- |
| [Abandons](TPScript.TModule..Abandons.md 'KeepCoding.TPScript&lt;TModule&gt;.Abandons') | This list contains modules that it should stop processing. Currently, the only module that uses this capability is Souvenir.<br/> |
| [Help](TPScript.TModule..Help.md 'KeepCoding.TPScript&lt;TModule&gt;.Help') | The help message that gets sent when typing `!{id} help`.<br/> |
| [IsCancelCommand](TPScript.TModule..IsCancelCommand.md 'KeepCoding.TPScript&lt;TModule&gt;.IsCancelCommand') | Determines if it should cancel command processing. If this returns true, then stop processing the command, clean up, then do a `yield return Cancelled;` to acknowledge the cancel.<br/> |
| [IsTime](TPScript.TModule..IsTime.md 'KeepCoding.TPScript&lt;TModule&gt;.IsTime') | Determines if it is in Time Mode, where solves change the timer. This is useful for modules that use the timer's value.<br/> |
| [IsTimeSkippable](TPScript.TModule..IsTimeSkippable.md 'KeepCoding.TPScript&lt;TModule&gt;.IsTimeSkippable') | Determines if it should allow for the timer to be skipped when the module it is in, as well as any other modules that would like to skip time, are the only unsolved modules left on the bomb. <br/> |
| [IsTP](TPScript.TModule..IsTP.md 'KeepCoding.TPScript&lt;TModule&gt;.IsTP') | Determines if Twitch Plays is currently active. This is for modules that need to display different items, or use different rules if Twitch Plays is active.<br/> |
| [IsZen](TPScript.TModule..IsZen.md 'KeepCoding.TPScript&lt;TModule&gt;.IsZen') | Determines if the timer is counting up instead of down, for special cases, such as controlling how to sort button release times, or whether there is a low timer event or not.<br/> |
| [Manual](TPScript.TModule..Manual.md 'KeepCoding.TPScript&lt;TModule&gt;.Manual') | Specifies the manual that is looked up on The Manual Repository when `!{id} manual` is entered into chat.<br/> |
| [Module](TPScript.TModule..Module.md 'KeepCoding.TPScript&lt;TModule&gt;.Module') | The instance of the module.<br/> |

| Methods | |
| :--- | :--- |
| [AwardPoints(int)](TPScript.TModule..AwardPoints.1aQxAe7DnKEpVGc3KT2kuQ.md 'KeepCoding.TPScript&lt;TModule&gt;.AwardPoints(int)') | Yield return this to award the user that sent the command points directly, this is currently used for mods like Souvenir to give points to users that answered the questions equally.<br/> |
| [AwardPointsOnSolve(int)](TPScript.TModule..AwardPointsOnSolve.vG+k8WxXPXlgdh15+2Gb7w.md 'KeepCoding.TPScript&lt;TModule&gt;.AwardPointsOnSolve(int)') | Yield return this to award the last user that sent the command points when the module is solved. The module must prevent any user from sending commands afterward in order for Twitch Plays to award points to the correct user. This is currently used by the Twin module when extra points must be given but the module is not solved immediately.<br/> |
| [Detonate(Nullable&lt;float&gt;, string)](TPScript.TModule..Detonate.nOD0hjHO3sqsByLZ4pLE7w.md 'KeepCoding.TPScript&lt;TModule&gt;.Detonate(System.Nullable&lt;float&gt;, string)') | Yield return this to explode the bomb instantly. [time](TPScript.TModule..Detonate.nOD0hjHO3sqsByLZ4pLE7w.md#KeepCoding.TPScript.TModule..Detonate(System.Nullable.float..string).time 'KeepCoding.TPScript&lt;TModule&gt;.Detonate(System.Nullable&lt;float&gt;, string).time') is specified in number of seconds before the bomb explodes. (Note, sending another detonate command will auto-cancel the previous one on the same module if it hasn't happened already.). [message](TPScript.TModule..Detonate.nOD0hjHO3sqsByLZ4pLE7w.md#KeepCoding.TPScript.TModule..Detonate(System.Nullable.float..string).message 'KeepCoding.TPScript&lt;TModule&gt;.Detonate(System.Nullable&lt;float&gt;, string).message') is the message to send to chat upon detonation. Both of the parameters are optional.<br/> |
| [Evaluate&lt;T&gt;(bool, T, object)](TPScript.TModule..Evaluate.DwrQLuJatSgu57qD5a7laQ.md 'KeepCoding.TPScript&lt;TModule&gt;.Evaluate&lt;T&gt;(bool, T, object)') | Works as a ternary operator. Returns [then](TPScript.TModule..Evaluate.DwrQLuJatSgu57qD5a7laQ.md#KeepCoding.TPScript.TModule..Evaluate.T.(bool.T.object).then 'KeepCoding.TPScript&lt;TModule&gt;.Evaluate&lt;T&gt;(bool, T, object).then') if [condition](TPScript.TModule..Evaluate.DwrQLuJatSgu57qD5a7laQ.md#KeepCoding.TPScript.TModule..Evaluate.T.(bool.T.object).condition 'KeepCoding.TPScript&lt;TModule&gt;.Evaluate&lt;T&gt;(bool, T, object).condition') is true, otherwise [otherwise](TPScript.TModule..Evaluate.DwrQLuJatSgu57qD5a7laQ.md#KeepCoding.TPScript.TModule..Evaluate.T.(bool.T.object).otherwise 'KeepCoding.TPScript&lt;TModule&gt;.Evaluate&lt;T&gt;(bool, T, object).otherwise').<br/> |
| [ForceSolve()](TPScript.TModule..ForceSolve().md 'KeepCoding.TPScript&lt;TModule&gt;.ForceSolve()') | When the module runs into an exception or the module is forced to be solved, it calls this method.<br/> |
| [IsMatch(string, string, bool, RegexOptions)](TPScript.TModule..IsMatch.vG.WTmQ.fGgmTR6dOiPC7g.md 'KeepCoding.TPScript&lt;TModule&gt;.IsMatch(string, string, bool, System.Text.RegularExpressions.RegexOptions)') | Determines whether the input string matches the regex of the pattern.<br/> |
| [OnInteractSequence(KMSelectable[], float, int[])](TPScript.TModule..OnInteractSequence.BDCqLwYKYl5pAjSBekGAmQ.md 'KeepCoding.TPScript&lt;TModule&gt;.OnInteractSequence(KMSelectable[], float, int[])') | Presses a sequence of buttons according to [indices](TPScript.TModule..OnInteractSequence.BDCqLwYKYl5pAjSBekGAmQ.md#KeepCoding.TPScript.TModule..OnInteractSequence(KMSelectable...float.int..).indices 'KeepCoding.TPScript&lt;TModule&gt;.OnInteractSequence(KMSelectable[], float, int[]).indices') within [selectables](TPScript.TModule..OnInteractSequence.BDCqLwYKYl5pAjSBekGAmQ.md#KeepCoding.TPScript.TModule..OnInteractSequence(KMSelectable...float.int..).selectables 'KeepCoding.TPScript&lt;TModule&gt;.OnInteractSequence(KMSelectable[], float, int[]).selectables'), waiting [wait](TPScript.TModule..OnInteractSequence.BDCqLwYKYl5pAjSBekGAmQ.md#KeepCoding.TPScript.TModule..OnInteractSequence(KMSelectable...float.int..).wait 'KeepCoding.TPScript&lt;TModule&gt;.OnInteractSequence(KMSelectable[], float, int[]).wait') seconds in-between each, and interrupting as soon as [HasStruck](ModuleScript.HasStruck.md 'KeepCoding.ModuleScript.HasStruck') is true.<br/> |
| [Process(string)](TPScript.TModule..Process.KVA0HcMKHcn6ZE3rntOuvA.md 'KeepCoding.TPScript&lt;TModule&gt;.Process(string)') | When a command is typed into Twitch Plays with the Id of this module, it calls this method and passes in the exact command typed.<br/> |
| [ProcessTwitchCommand(string)](TPScript.TModule..ProcessTwitchCommand.NJjTAUJur3QxQdZPRU1gHw.md 'KeepCoding.TPScript&lt;TModule&gt;.ProcessTwitchCommand(string)') | This method gets grabbed by Twitch Plays. It grabs [Process(string)](TPScript.TModule..Process.KVA0HcMKHcn6ZE3rntOuvA.md 'KeepCoding.TPScript&lt;TModule&gt;.Process(string)') and flattens it using [Flatten(IEnumerator, Predicate&lt;IEnumerator&gt;)](Helper.Flatten.1fU+zZAhpugERKJvQxZvsQ.md 'KeepCoding.Helper.Flatten(System.Collections.IEnumerator, System.Predicate&lt;System.Collections.IEnumerator&gt;)').<br/> |
| [SendDelayedMessage(float, string)](TPScript.TModule..SendDelayedMessage.XNRomoqws6k9UP7HETRG.A.md 'KeepCoding.TPScript&lt;TModule&gt;.SendDelayedMessage(float, string)') | Yield return this to send a message to chat after [time](TPScript.TModule..SendDelayedMessage.XNRomoqws6k9UP7HETRG.A.md#KeepCoding.TPScript.TModule..SendDelayedMessage(float.string).time 'KeepCoding.TPScript&lt;TModule&gt;.SendDelayedMessage(float, string).time') seconds.<br/> |
| [SendToChat(string)](TPScript.TModule..SendToChat.ruWXca0823R.yuJpe7zj3A.md 'KeepCoding.TPScript&lt;TModule&gt;.SendToChat(string)') | Yield return this to send a chat directly to twitch chat.<br/> |
| [SendToChatError(string)](TPScript.TModule..SendToChatError.mAbBbSGK0BCR9bHN6CfMIQ.md 'KeepCoding.TPScript&lt;TModule&gt;.SendToChatError(string)') | Yield return this to send a message to the chat about why a users' command was invalid.<br/> |
| [SkipTime(string)](TPScript.TModule..SkipTime.+mbdek6zTJ61HUOtM46AHg.md 'KeepCoding.TPScript&lt;TModule&gt;.SkipTime(string)') | Yield return this to try advancing the clock to the specified time. You must put the full time you wish to skip to, and this time either needs to be less than the current time, if in normal/time mode, or greater than the current time, if in zen mode. Example, if you wanted to set the clock to 5:24, then you do "skiptime 324" or "skiptime 5:24". You can target partway through the seconds, such as "skiptime 45.28", which would then set the clock to 45.28, provided that time has NOT gone by already. You must also set [IsTimeSkippable](TPScript.TModule..IsTimeSkippable.md 'KeepCoding.TPScript&lt;TModule&gt;.IsTimeSkippable') to true, for this function to work.<br/> |
| [StrikeMessage(string)](TPScript.TModule..StrikeMessage.bWkiCHYyoBLM2RzZLLMrvQ.md 'KeepCoding.TPScript&lt;TModule&gt;.StrikeMessage(string)') | Yield return this to allow you to tell the user why they got a strike if it isn't clear.<br/> |
| [TryCancel(string)](TPScript.TModule..TryCancel.v0CCl9QqzqpK.IUIHpIsiA.md 'KeepCoding.TPScript&lt;TModule&gt;.TryCancel(string)') | Yield return this to indicate that this command is allowed to be cancelled at the given time of the yield. Just know that you won't be able to clean up if you do your cancel this way, and there is a pending !cancel or !stop.<br/> |
| [TryWaitCancel(float, string)](TPScript.TModule..TryWaitCancel.GeEmQxUieZkc.2lg0RtsHw.md 'KeepCoding.TPScript&lt;TModule&gt;.TryWaitCancel(float, string)') | Yield return this to cause Twitch Plays to wait for the given time, and any time during the entire duration, the command may cancel. Like "trycancel", you won't be able to clean up if you cancel this way. Also like "trycancel", [message](TPScript.TModule..TryWaitCancel.GeEmQxUieZkc.2lg0RtsHw.md#KeepCoding.TPScript.TModule..TryWaitCancel(float.string).message 'KeepCoding.TPScript&lt;TModule&gt;.TryWaitCancel(float, string).message') is optional.<br/> |
| [TwitchHandleForcedSolve()](TPScript.TModule..TwitchHandleForcedSolve().md 'KeepCoding.TPScript&lt;TModule&gt;.TwitchHandleForcedSolve()') | This method gets grabbed by Twitch Plays. It grabs [ForceSolve()](TPScript.TModule..ForceSolve().md 'KeepCoding.TPScript&lt;TModule&gt;.ForceSolve()') and flattens it using [Flatten(IEnumerator, Predicate&lt;IEnumerator&gt;)](Helper.Flatten.1fU+zZAhpugERKJvQxZvsQ.md 'KeepCoding.Helper.Flatten(System.Collections.IEnumerator, System.Predicate&lt;System.Collections.IEnumerator&gt;)').<br/> |
| [YieldUntil&lt;T&gt;(T, Func&lt;bool&gt;)](TPScript.TModule..YieldUntil..nUK6ELh9qhTbrWr9m2Iiw.md 'KeepCoding.TPScript&lt;TModule&gt;.YieldUntil&lt;T&gt;(T, System.Func&lt;bool&gt;)') | You can yield return this to repeatedly yield return an item until a condition is met.<br/> |
| [YieldWhile&lt;T&gt;(T, Func&lt;bool&gt;)](TPScript.TModule..YieldWhile.Ac4tido+mXp0Y.5imr1xlg.md 'KeepCoding.TPScript&lt;TModule&gt;.YieldWhile&lt;T&gt;(T, System.Func&lt;bool&gt;)') | You can yield return this to repeatedly yield return an item until a condition is no longer met.<br/> |
